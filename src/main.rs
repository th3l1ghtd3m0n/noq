// O_o
use std::fmt;
use std::collections::HashMap;

#[derive(Debug, Clone, PartialEq)]
enum Expr
{
    Sym(String),
    Fun(String, Vec<Expr>),
}

impl fmt::Display for Expr
{
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result
    {
        match self
        {
            Expr::Sym(name) => write!(f, "{}", name),
            Expr::Fun(name, args) => {
                write!(f, "{}(", name)?;
                for (i, arg) in args.iter().enumerate()
                {
                    if i > 0 { write!(f, ", ")? }
                    write!(f, "{}", arg)?;
                }
                write!(f, ")")
            }
        }
    }
}

#[derive(Debug)]
struct Rule
{
    head: Expr,
    body: Expr
}

fn substitute_bindings(bindings: &Bindings, expr: &Expr) -> Expr
{
    use Expr::*;
    match expr
    {
        Sym(name) => {
            if let Some(value) = bindings.get(name)
            {
                return value.clone();
            } else
            {
                return expr.clone();
            }
        },
        Fun(name, args) => {
            let new_name = match bindings.get(name)
            {
                Some(Sym(new_name)) => new_name.clone(),
                None => name.clone(),
                Some(_) => panic!("Expected symbol in the place of the functor name"),
            };
            let mut new_args = Vec::new();
            for arg in args
            {
                new_args.push(substitute_bindings(bindings, &arg))
            }
            return Fun(new_name, new_args);
        }
    }
}

impl Rule
{
    fn apply_all(&self, expr: &Expr) -> Expr
    {
        if let Some(bindings) = pattern_match(&self.head, expr)
        {
            substitute_bindings(&bindings, &self.body)
        } else
        {
            use Expr::*;
            match expr
            {
                Sym(_) => expr.clone(),
                Fun(name, args) => {
                    let mut new_args = Vec::new();
                    for arg in args 
                    {
                        new_args.push(self.apply_all(arg))
                    }
                    Fun(name.clone(), new_args)
                }
            }
        }
    }
}

impl fmt::Display for Rule
{
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result
    {
        write!(f, "{} => {}", self.head, self.body)
    }
}

type Bindings = HashMap<String, Expr>;


fn pattern_match(pattern: &Expr, value: &Expr) -> Option<Bindings>
{
    fn pattern_match_impl(pattern: &Expr, value: &Expr, bindings: &mut Bindings) -> bool
    {
        use Expr::*;
        match (pattern, value)
        {
            (Sym(name), _) => {
                if let Some(bound_value) = bindings.get(name)
                {
                    bound_value == value
                } else
                {
                    bindings.insert(name.clone(), value.clone());
                    true
                }
            },
            (Fun(name1, args1), Fun(name2, args2)) => {
                if name1 == name2 && args1.len() == args2.len()
                {
                    for i in 0..args1.len()
                    {
                        if !pattern_match_impl(&args1[i], &args2[i], bindings)
                        {
                            return false;
                        }
                    }
                    true
                } else
                {
                    false
                }
            },
            _ => false,
        }
    }

    let mut bindings = HashMap::new();

    if pattern_match_impl(pattern, value, &mut bindings)
    {
        Some(bindings)
    } else
    {
        None
    }
}

macro_rules! sym 
{
    ($name:ident) => {
        Expr::Sym(stringify!($name).to_string())
    }
}

macro_rules! fun 
{
    ($name:ident) => {
        Expr::Fun(stringify!($name).to_string(), vec![])
    };
    ($name:ident,$($args:expr),*) => {
        Expr::Fun(stringify!($name).to_string(), vec![$($args),*])
    }
}

#[cfg(test)]
mod test
{
    use super::*;

    #[test]
    pub fn rule_apply_all()
    {
        // swap(pair(a, b)) = pair(b, a)
        let swap = Rule {
            head: fun!(swap, fun!(pair, sym!(a), sym!(b))),
            body: fun!(pair, sym!(b), sym!(a)),
        };

        let input = fun!(foo, fun!(swap, 
            fun!(pair, fun!(f, sym!(a)), 
                fun!(g, sym!(b)))), fun!(swap,
                    fun!(pair, fun!(q, sym!(c)), fun!(z, sym!(d)))));

        let expected = fun!(foo, fun!(pair,
            fun!(g, sym!(b)), fun!(f, sym!(a))),
                fun!(pair, fun!(z, sym!(d)), fun!(q, sym!(c))));

        assert_eq!(swap.apply_all(&input), expected);
    }
}

fn main()
{}
